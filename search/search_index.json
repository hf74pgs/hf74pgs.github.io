{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"overview","text":"<p>\u30d7\u30ed\u30b0\u30e9\u30e0\u3084Git\u306b\u3064\u3044\u3066\u306e\u96d1\u591a\u306a\u30e1\u30e2.</p>"},{"location":"csharp-1-basics/","title":"CSV","text":""},{"location":"csharp-1-basics/#csv-parameter-settings","title":"csv Parameter Settings","text":"<p>```csharp</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing HalconDotNet;\n\npublic static class HalconCameraConfig\n{\n    /// &lt;summary&gt;\n    /// Set camera parameters from a 2-row CSV file (header + values)\n    /// &lt;/summary&gt;\n    public static void ApplyCameraParamsFromCsv2Row(HTuple acqHandle, string csvFilePath)\n    {\n        if (!File.Exists(csvFilePath))\n            throw new FileNotFoundException(\"CSV file not found\", csvFilePath);\n\n        var lines = File.ReadAllLines(csvFilePath);\n        if (lines.Length &lt; 2)\n            throw new FormatException(\"CSV file must contain two rows: header and values\");\n\n        var headers = lines[0].Split(',');\n        var values = lines[1].Split(',');\n\n        if (headers.Length != values.Length)\n            throw new FormatException(\"The number of headers and values do not match\");\n\n        for (int i = 0; i &lt; headers.Length; i++)\n        {\n            string key = headers[i].Trim();\n            string valStr = values[i].Trim();\n\n            if (string.IsNullOrEmpty(key))\n                continue;\n\n            HTuple val;\n            if (double.TryParse(valStr, out double d))\n                val = d;\n            else if (int.TryParse(valStr, out int n))\n                val = n;\n            else\n                val = valStr;\n\n            try\n            {\n                HOperatorSet.SetFramegrabberParam(acqHandle, key, val);\n                Console.WriteLine($\"Set: {key} = {val}\");\n            }\n            catch (HalconException ex)\n            {\n                Console.WriteLine($\"Failed to set parameter: {key} = {val} \u2192 {ex.Message}\");\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Save parameters as 2-row CSV (header + values) from a dictionary\n    /// &lt;/summary&gt;\n    public static void SaveCameraParamsToCsv2Row(string csvFilePath, Dictionary&lt;string, string&gt; paramDict)\n    {\n        if (paramDict == null || paramDict.Count == 0)\n            throw new ArgumentException(\"Parameter dictionary is empty\", nameof(paramDict));\n\n        var headers = string.Join(\",\", paramDict.Keys);\n        var values = string.Join(\",\", paramDict.Values);\n\n        File.WriteAllLines(csvFilePath, new[] { headers, values });\n    }\n}\n</code></pre>"},{"location":"csharp-2-advanced/","title":"Csharp 2 advanced","text":""},{"location":"csharp-2-advanced/#halcon","title":"Halcon","text":"<p>This is an industrial image processing sample that uses a GigE Vision compatible camera and the MVTec Halcon library to acquire, connect, and save line scan images at high speed and high precision. Images are acquired line by line in synchronization with an external trigger signal, and multiple lines are combined vertically or horizontally to create a scanned image of the entire object.</p> <p>A simple line scan experiment using Halcon to acquire images one line at a time from a GigE Vision-compatible line scan camera in response to an external trigger, and then combine them vertically and save them as an image.</p>"},{"location":"csharp-2-advanced/#technology-stack","title":"Technology Stack","text":"<p>Language: C# (.NET 6.0 or later) Image Processing: MVTec Halcon 20.11 or later Supported Cameras: GigE Vision (line scan compatible models) Input/Output: External trigger input, PNG/JPEG output, CSV configuration file</p> <p>```csharp</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing HalconDotNet;\n\nnamespace HalconLineScanTriggerSample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // === Settings (modify as needed) ===\n            int numLinesToGrab = 2000;                        // Number of lines to acquire (N)\n            string savePath = @\"C:\\Images\\linescan_result.png\";\n            string deviceUserID = \"0\";                        // First found device or Camera UserID\n            string triggerSource = \"Line1\";                   // External trigger input line\n            string triggerActivation = \"RisingEdge\";          // Rising/Falling edge\n            int grabTimeoutMs = -1;                           // -1: Wait indefinitely (depending on model, \"grab_timeout\" may also be used)\n            bool enforceSameWidth = true;                     // Ensure same width for safety (should be same width basically)\n\n            HTuple acqHandle = null;\n            var lineImages = new List&lt;HObject&gt;(capacity: numLinesToGrab);\n\n            try\n            {\n                acqHandle = OpenGigEVision(deviceUserID);\n\n                // LineStart (1 pulse = 1 line acquisition)\n                ConfigureLineTrigger(acqHandle, triggerSource, triggerActivation);\n\n                // Specify pixel format if needed (e.g., monochrome)\n                // HOperatorSet.SetFramegrabberParam(acqHandle, \"PixelFormat\", \"Mono8\");\n\n                HOperatorSet.GrabImageStart(acqHandle, -1);\n\n                // Acquire N lines (returns one line per external trigger)\n                for (int i = 0; i &lt; numLinesToGrab; i++)\n                {\n                    HObject oneLine = GrabOneLine(acqHandle, grabTimeoutMs);\n                    lineImages.Add(oneLine);\n                    if ((i + 1) % 100 == 0) Console.WriteLine($\"Grabbed lines: {i + 1}/{numLinesToGrab}\");\n                }\n\n                // Option to align widths for safety (should be same width basically)\n                if (enforceSameWidth) EqualizeWidthsInPlace(lineImages);\n\n                // Combine vertically (N rows x 1 column) to create 2D image\n                HObject fullImage = TileImagesVertically(lineImages);\n\n                Directory.CreateDirectory(Path.GetDirectoryName(savePath) ?? \".\");\n                HOperatorSet.WriteImage(fullImage, GetExtAsHalconType(savePath), 0, savePath);\n                Console.WriteLine($\"Saved: {savePath}\");\n\n                fullImage.Dispose();\n            }\n            catch (HalconException hex)\n            {\n                Console.Error.WriteLine($\"HALCON ERROR: #{hex.GetErrorCode()} {hex.GetErrorMessage()}\");\n            }\n            catch (Exception ex)\n            {\n                Console.Error.WriteLine($\"ERROR: {ex.Message}\");\n            }\n            finally\n            {\n                foreach (var img in lineImages) img?.Dispose();\n                if (acqHandle != null &amp;&amp; acqHandle.IsInitialized())\n                {\n                    try { HOperatorSet.CloseFramegrabber(acqHandle); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // Open GigE Vision frame grabber\n        static HTuple OpenGigEVision(string deviceUserID)\n        {\n            HOperatorSet.OpenFramegrabber(\n                \"GigEVision\",\n                0, 0, 0, 0, 0, 0,\n                \"progressive\",\n                -1,\n                \"default\",\n                -1,\n                \"false\",      // External trigger details set below\n                \"default\",\n                deviceUserID, // \"0\" or Camera UserID\n                0,\n                -1,\n                out HTuple acqHandle);\n\n            // Set bandwidth etc. here if needed (model dependent)\n            // HOperatorSet.SetFramegrabberParam(acqHandle, \"GevSCPSPacketSize\", 9000);\n\n            return acqHandle;\n        }\n\n        // Set line trigger (GenICam keys are model dependent. General example)\n        static void ConfigureLineTrigger(HTuple acqHandle, string triggerSource, string triggerActivation)\n        {\n            // Which event to trigger on: line unit\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerSelector\", \"LineStart\");\n\n            // Enable trigger\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerMode\", \"On\");\n\n            // External input line or encoder etc. (e.g., Line1)\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerSource\", triggerSource);\n\n            // Rising/Falling edge\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerActivation\", triggerActivation);\n\n            // Set exposure or gain if needed\n            // HOperatorSet.SetFramegrabberParam(acqHandle, \"ExposureTime\", 20_000.0); // Example: 20,000 us\n            // For encoder synchronization, set model-specific features (e.g., LineTriggerSource=\"Encoder\" etc.)\n        }\n\n        // Acquire one line (blocks until external trigger arrives)\n        static HObject GrabOneLine(HTuple acqHandle, int timeoutMs)\n        {\n            // The third argument of GrabImageAsync is -1 for infinite wait. If you want to use timeout, set \"grab_timeout\" if supported by the model\n            HOperatorSet.GrabImageAsync(out HObject lineImg, acqHandle, -1);\n            return lineImg;\n        }\n\n        static HObject GrabOneLineOrBlack(HTuple acqHandle, int timeoutMs, int fallbackWidth = 4096, string pixelType = \"byte\")\n        {\n            try\n            {\n                // Normal 1-line acquisition (wait for external trigger)\n                HOperatorSet.GrabImageAsync(out HObject lineImg, acqHandle, -1);\n                return lineImg;\n            }\n            catch (HalconException ex)\n            {\n                Console.WriteLine($\"Grab failed: {ex.Message}  Fill with black line\");\n\n                // Generate a black image with a height of 1px (width can be specified as needed)\n                HOperatorSet.GenImageConst(out HObject blankLine, pixelType, fallbackWidth, 1);\n                return blankLine;\n            }\n        }\n\n\n        // Combine images vertically (N rows x 1 column)\n        static HObject TileImagesVertically(List&lt;HObject&gt; imageList)\n        {\n            if (imageList == null || imageList.Count == 0)\n                throw new ArgumentException(\"imageList is empty.\");\n\n            HOperatorSet.GenEmptyObj(out HObject all);\n            foreach (var img in imageList)\n            {\n                HOperatorSet.ConcatObj(all, img, out all);\n            }\n\n            HOperatorSet.TileImages(all, out HObject tiled, imageList.Count, 1);\n            all.Dispose();\n            return tiled;\n        }\n\n        // Align widths to the maximum (should be same width basically, but for safety)\n        static void EqualizeWidthsInPlace(List&lt;HObject&gt; imageList)\n        {\n            int maxWidth = 0;\n            var sizes = new List&lt;(int w, int h)&gt;(imageList.Count);\n\n            foreach (var img in imageList)\n            {\n                HOperatorSet.GetImageSize(img, out HTuple w, out HTuple h);\n                int wi = w.I, hi = h.I;         // For line, h is usually 1\n                sizes.Add((wi, hi));\n                if (wi &gt; maxWidth) maxWidth = wi;\n            }\n\n            for (int i = 0; i &lt; imageList.Count; i++)\n            {\n                var (w, h) = sizes[i];\n                if (w == maxWidth) continue;\n\n                double scale = (double)maxWidth / Math.Max(1, w);\n                int newH = Math.Max(1, (int)Math.Round(h * scale)); // h=1 is usual\n                HOperatorSet.ZoomImageSize(imageList[i], out HObject resized, maxWidth, newH, \"constant\");\n                imageList[i].Dispose();\n                imageList[i] = resized;\n            }\n        }\n\n        // Extension -&gt; HALCON write type\n        static string GetExtAsHalconType(string path)\n        {\n            var ext = Path.GetExtension(path)?.ToLowerInvariant();\n            return ext switch\n            {\n                \".png\" =&gt; \"png\",\n                \".jpg\" or \".jpeg\" =&gt; \"jpeg\",\n                \".bmp\" =&gt; \"bmp\",\n                \".tif\" or \".tiff\" =&gt; \"tiff\",\n                _ =&gt; \"png\"\n            };\n        }\n    }\n</code></pre>"},{"location":"git/","title":"Git\u57fa\u672c\u64cd\u4f5c","text":""},{"location":"git/#_1","title":"\u30af\u30ed\u30fc\u30f3\uff08\u30ea\u30e2\u30fc\u30c8\u304b\u3089\u30b3\u30d4\u30fc\u3092\u4f5c\u308b\uff09","text":"<p>git clone git@server:/path/to/repo.git</p> <p>\u5b9f\u884c\u5f8c\u3001repo \u3068\u3044\u3046\u30d5\u30a9\u30eb\u30c0\u304c\u4f5c\u6210\u3055\u308c\u3001\u305d\u306e\u4e2d\u306b\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u5185\u5bb9\u304c\u30b3\u30d4\u30fc\u3055\u308c\u307e\u3059</p>"},{"location":"git/#_2","title":"\u65e2\u5b58\u306e\u30d6\u30e9\u30f3\u30c1\u3092\u898b\u308b","text":"<p>git branch        # \u30ed\u30fc\u30ab\u30eb\u306e\u30d6\u30e9\u30f3\u30c1 git branch -r     # \u30ea\u30e2\u30fc\u30c8\u306e\u30d6\u30e9\u30f3\u30c1</p>"},{"location":"git/#_3","title":"\u65e2\u5b58\u306e\u30ea\u30e2\u30fc\u30c8\u30d6\u30e9\u30f3\u30c1\u306b\u5207\u308a\u66ff\u3048\u308b\u5834\u5408","text":"<p>git checkout -b your-branch-name origin/your-branch-name</p>"},{"location":"git/#_4","title":"\u5909\u66f4\u3092\u78ba\u8a8d","text":"<p>git status </p>"},{"location":"git/#_5","title":"\u30b9\u30c6\u30fc\u30b8\u306b\u8ffd\u52a0\uff08\u8ffd\u8de1\u5bfe\u8c61\u306b\uff09","text":"<p>git add main.cpp        # \u500b\u5225\u306b\u8ffd\u52a0  git add .               # \u5168\u90e8\u307e\u3068\u3081\u3066\u8ffd\u52a0 </p>"},{"location":"git/#_6","title":"\u30b3\u30df\u30c3\u30c8\uff08\u30ed\u30fc\u30ab\u30eb\u5c65\u6b74\u306b\u8a18\u9332\uff09","text":"<p>git commit -m \"\u6a5f\u80fd\u8ffd\u52a0: \u30e1\u30a4\u30f3\u51e6\u7406\u3092\u5b9f\u88c5\"</p>"},{"location":"git/#_7","title":"\u6700\u65b0\u306e\u60c5\u5831\u3060\u3051\u53cd\u6620\uff08\u5b89\u5168\uff09","text":"<p>git fetch --prune --tags</p> <p>--prune\uff1a\u30ea\u30e2\u30fc\u30c8\u3067\u524a\u9664\u3055\u308c\u305f\u30d6\u30e9\u30f3\u30c1\u306e\u8ffd\u8de1\u30d6\u30e9\u30f3\u30c1\uff08\u4f8b\uff1aorigin/old-feature\uff09\u3092\u30ed\u30fc\u30ab\u30eb\u304b\u3089\u3082\u6383\u9664\u3057\u307e\u3059 --tags\uff1a\u3059\u3079\u3066\u306e\u30bf\u30b0\u3092\u53d6\u5f97\u3057\u307e\u3059</p> <p>git log --oneline --graph --decorate --all </p> <p> \u300choge\u30d6\u30e9\u30f3\u30c1 \u304c main \u306b\u30de\u30fc\u30b8\u6e08\u307f\u304b\u3069\u3046\u304b\u300d\u306e\u5224\u5b9a\u65b9\u6cd5  \u305d\u306e\u4e2d\u306b\u300cMerge branch 'feature/hoge'\u300d\u3068\u3044\u3063\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u3042\u308c\u3070\u3001\u30de\u30fc\u30b8\u6e08\u307f</p> <p>git log main --merges --oneline</p> <p>\u300c\u73fe\u5728\u3044\u308b\u30ed\u30fc\u30ab\u30eb\u30d6\u30e9\u30f3\u30c1\u300d\u3068\u300corigin/main\u300d\u306e\u30d5\u30a1\u30a4\u30eb\u5dee\u5206\u3092\u8868\u793a </p> <p>git diff origin/main </p>"},{"location":"git/#_8","title":"\u30ea\u30e2\u30fc\u30c8\u306b\u30d7\u30c3\u30b7\u30e5\uff08\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\uff09","text":"<p>git push origin your-branch-name origin\uff1a\u30ea\u30e2\u30fc\u30c8\u30ea\u30dd\u30b8\u30c8\u30ea\u306e\u540d\u524d\uff08\u901a\u5e38\u306f origin \u306e\u307e\u307e\uff09</p> <p> \u4e0a\u6d41\uff08upstream\uff09\u304c\u672a\u8a2d\u5b9a\u306e\u5834\u5408</p> <p>The current branch hoge has no upstream branch.</p> <p>\u306e\u3088\u3046\u306a\u30a8\u30e9\u30fc\u304c\u51fa\u308b \u2192  \u4e00\u5ea6\u3067\u3082\u4e0a\u6d41\u8a2d\u5b9a\u3092\u6e08\u307e\u305b\u308c\u3070\u3001\u305d\u306e\u5f8c\u306f git push \u3060\u3051\u3067OK</p> <p>git push -u origin your-branch-name         </p> <p>\u3042\u308b\u3044\u306f</p> <p>git push -u origin HEAD           # \u4eca\u3044\u308b\u30d6\u30e9\u30f3\u30c1\u540d\u3092\u81ea\u52d5\u3067\u4f7f\u3046</p> <p></p>"},{"location":"git/#2","title":"2\u56de\u76ee\u4ee5\u964d","text":"<p>git push          # \u3082\u3046 -u \u306f\u4e0d\u8981\u3002\u666e\u901a\u306b\u901a\u308b  git pull --rebase # \u8ffd\u5f93\u6642 </p>"},{"location":"git/#_9","title":"\u4ed6\u306e\u4eba\u306e\u66f4\u65b0\u3092\u53d6\u308a\u8fbc\u3080\uff08\u30d7\u30eb\uff09","text":"<p>git pull origin your-branch-name </p>"},{"location":"git/#_10","title":"\u30de\u30fc\u30b8","text":"<p>\u4f8b: feature \u30d6\u30e9\u30f3\u30c1\u3092 main \u306b\u53d6\u308a\u8fbc\u3080(feature\u304c\u6d88\u3048\u3066main\u304c\u6b8b\u308b) git checkout main git merge feature </p> <p>\u203b\u30ea\u30e2\u30fc\u30c8\u306e\u6700\u65b0\u72b6\u614b\u3092\u77e5\u308a\u305f\u3044\u306a\u3089\u3001\u307e\u305a git fetch \u304c\u5fc5\u8981</p>"},{"location":"git/#git-fetch","title":"git fetch","text":"<p>\u30ea\u30e2\u30fc\u30c8\u306e\u6700\u65b0\u72b6\u6cc1\u3092\u53d6\u5f97\u3057\u3066\u30ed\u30fc\u30ab\u30eb\u306b\u8a18\u9332\u3059\u308b\u3060\u3051\uff08\u4f5c\u696d\u4e2d\u30d6\u30e9\u30f3\u30c1\u306f\u4e00\u5207\u89e6\u3089\u306a\u3044\uff09 \u30ea\u30e2\u30fc\u30c8\u8ffd\u8de1\u30d6\u30e9\u30f3\u30c1\uff08\u4f8b\uff1aorigin/main, origin/feature/hoge\uff09\u304c\u66f4\u65b0\u3055\u308c\u308b \u30ef\u30fc\u30ad\u30f3\u30b0\u30c4\u30ea\u30fc/\u73fe\u5728\u306e\u30d6\u30e9\u30f3\u30c1\u306f\u5909\u5316\u306a\u3057 \u5b89\u5168\u306b\u300c\u6700\u65b0\u3092\u89b3\u5bdf\u300d\u3067\u304d\u308b</p>"},{"location":"git/#git-pull","title":"git pull","text":"<p>= git fetch \uff0b \u73fe\u5728\u306e\u30d6\u30e9\u30f3\u30c1\u3092\u66f4\u65b0\uff08\u30de\u30fc\u30b8 or \u30ea\u30d9\u30fc\u30b9\uff09 \u30c7\u30d5\u30a9\u30eb\u30c8\u306f fetch\u5f8c\u306b\u300c\u30de\u30fc\u30b8\u300d \u8a2d\u5b9a\u3057\u3060\u3044\u3067 fetch\u5f8c\u306b\u300c\u30ea\u30d9\u30fc\u30b9\u300d \u3078\u5909\u66f4\u53ef\u80fd \u4f5c\u696d\u4e2d\u306e\u30d6\u30e9\u30f3\u30c1\u306b\u5909\u66f4\u304c\u5165\u308a\u3046\u308b\uff08\u30b3\u30f3\u30d5\u30ea\u30af\u30c8\u3082\u8d77\u304d\u3046\u308b\uff09 git pull \u306f\u300c\u73fe\u5728\u306e\u30d6\u30e9\u30f3\u30c1\u300d\u3057\u304b\u66f4\u65b0\u3057\u306a\u3044 </p>"},{"location":"git/#_11","title":"\u307e\u3068\u3081","text":"<pre><code># 1. \u6700\u65b0\u306e\u30ea\u30e2\u30fc\u30c8\u60c5\u5831\u3092\u53d6\u308b\ngit fetch --prune --tags\n\n# 2. main \u3092\u6700\u65b0\u5316\ngit switch main\ngit pull --rebase   # main \u3092 origin/main \u306b\u8ffd\u5f93\n\n# 3. \u518d\u3073 hoge \u30d6\u30e9\u30f3\u30c1\u306b\u623b\u308b\ngit switch feature/hoge\n\n# 4. main \u306e\u6700\u65b0\u3092\u53d6\u308a\u8fbc\u3080\uff08\u30ea\u30d9\u30fc\u30b9\u63a8\u5968\uff09\ngit rebase main\n# or \u30de\u30fc\u30b8\u3059\u308b\u5834\u5408\u306f: git merge main\n\n# 5. \u30ea\u30e2\u30fc\u30c8\u306b\u66f4\u65b0\u3092\u53cd\u6620\ngit push --force-with-lease   # rebase \u3057\u305f\u306a\u3089\u5fc5\u9808\n# or\ngit push                      # merge \u3057\u305f\u306a\u3089\u3053\u308c\u3067OK\n</code></pre>"},{"location":"golang-1/","title":"Go","text":"<p>Here is a basic code example for implementing the server side in Go. In this example, we will create a simple web server with the following functions.</p> <p>GET / : Returns \u201cHello, World!\u201d</p> <p>GET /users : Returns a list of users in JSON format</p> <p>POST /users : Adds a user (accepts JSON)</p> <p>```go</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\n// User model\ntype User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nvar users = []User{\n    {ID: 1, Name: \"Alice\"},\n    {ID: 2, Name: \"Bob\"},\n}\n\n// Handler: \"/\" \u2192 return Hello, World!\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, World!\")\n}\n\n// Handler: \"/users\" (GET) \u2192 return user list\nfunc getUsersHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(users)\n}\n\n// Handler: \"/users\" (POST) \u2192 add a new user\nfunc createUserHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodPost {\n        http.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    var newUser User\n    if err := json.NewDecoder(r.Body).Decode(&amp;newUser); err != nil {\n        http.Error(w, \"Bad Request\", http.StatusBadRequest)\n        return\n    }\n\n    newUser.ID = len(users) + 1\n    users = append(users, newUser)\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(newUser)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", helloHandler)\n    http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n        if r.Method == http.MethodGet {\n            getUsersHandler(w, r)\n        } else if r.Method == http.MethodPost {\n            createUserHandler(w, r)\n        } else {\n            http.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n        }\n    })\n\n    fmt.Println(\"\ud83d\ude80 Server is running at http://localhost:8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"}]}