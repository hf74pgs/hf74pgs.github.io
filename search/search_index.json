{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"overview","text":"<p>Introducing basic code for various programs.</p>"},{"location":"csharp-1-basics/","title":"CSV","text":""},{"location":"csharp-1-basics/#csv-parameter-settings","title":"csv Parameter Settings","text":"<p>```csharp</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing HalconDotNet;\n\npublic static class HalconCameraConfig\n{\n    /// &lt;summary&gt;\n    /// Set camera parameters from a 2-row CSV file (header + values)\n    /// &lt;/summary&gt;\n    public static void ApplyCameraParamsFromCsv2Row(HTuple acqHandle, string csvFilePath)\n    {\n        if (!File.Exists(csvFilePath))\n            throw new FileNotFoundException(\"CSV file not found\", csvFilePath);\n\n        var lines = File.ReadAllLines(csvFilePath);\n        if (lines.Length &lt; 2)\n            throw new FormatException(\"CSV file must contain two rows: header and values\");\n\n        var headers = lines[0].Split(',');\n        var values = lines[1].Split(',');\n\n        if (headers.Length != values.Length)\n            throw new FormatException(\"The number of headers and values do not match\");\n\n        for (int i = 0; i &lt; headers.Length; i++)\n        {\n            string key = headers[i].Trim();\n            string valStr = values[i].Trim();\n\n            if (string.IsNullOrEmpty(key))\n                continue;\n\n            HTuple val;\n            if (double.TryParse(valStr, out double d))\n                val = d;\n            else if (int.TryParse(valStr, out int n))\n                val = n;\n            else\n                val = valStr;\n\n            try\n            {\n                HOperatorSet.SetFramegrabberParam(acqHandle, key, val);\n                Console.WriteLine($\"Set: {key} = {val}\");\n            }\n            catch (HalconException ex)\n            {\n                Console.WriteLine($\"Failed to set parameter: {key} = {val} \u2192 {ex.Message}\");\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Save parameters as 2-row CSV (header + values) from a dictionary\n    /// &lt;/summary&gt;\n    public static void SaveCameraParamsToCsv2Row(string csvFilePath, Dictionary&lt;string, string&gt; paramDict)\n    {\n        if (paramDict == null || paramDict.Count == 0)\n            throw new ArgumentException(\"Parameter dictionary is empty\", nameof(paramDict));\n\n        var headers = string.Join(\",\", paramDict.Keys);\n        var values = string.Join(\",\", paramDict.Values);\n\n        File.WriteAllLines(csvFilePath, new[] { headers, values });\n    }\n}\n</code></pre>"},{"location":"csharp-2-advanced/","title":"Halcon","text":""},{"location":"csharp-2-advanced/#halcon","title":"Halcon","text":"<p>This is an industrial image processing sample that uses a GigE Vision compatible camera and the MVTec Halcon library to acquire, connect, and save line scan images at high speed and high precision. Images are acquired line by line in synchronization with an external trigger signal, and multiple lines are combined vertically or horizontally to create a scanned image of the entire object.</p> <p>A simple line scan experiment using Halcon to acquire images one line at a time from a GigE Vision-compatible line scan camera in response to an external trigger, and then combine them vertically and save them as an image.</p>"},{"location":"csharp-2-advanced/#technology-stack","title":"Technology Stack","text":"<p>Language: C# (.NET 6.0 or later) Image Processing: MVTec Halcon 20.11 or later Supported Cameras: GigE Vision (line scan compatible models) Input/Output: External trigger input, PNG/JPEG output, CSV configuration file</p> <p>```csharp</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing HalconDotNet;\n\nnamespace HalconLineScanTriggerSample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // === Settings (modify as needed) ===\n            int numLinesToGrab = 2000;                        // Number of lines to acquire (N)\n            string savePath = @\"C:\\Images\\linescan_result.png\";\n            string deviceUserID = \"0\";                        // First found device or Camera UserID\n            string triggerSource = \"Line1\";                   // External trigger input line\n            string triggerActivation = \"RisingEdge\";          // Rising/Falling edge\n            int grabTimeoutMs = -1;                           // -1: Wait indefinitely (depending on model, \"grab_timeout\" may also be used)\n            bool enforceSameWidth = true;                     // Ensure same width for safety (should be same width basically)\n\n            HTuple acqHandle = null;\n            var lineImages = new List&lt;HObject&gt;(capacity: numLinesToGrab);\n\n            try\n            {\n                acqHandle = OpenGigEVision(deviceUserID);\n\n                // LineStart (1 pulse = 1 line acquisition)\n                ConfigureLineTrigger(acqHandle, triggerSource, triggerActivation);\n\n                // Specify pixel format if needed (e.g., monochrome)\n                // HOperatorSet.SetFramegrabberParam(acqHandle, \"PixelFormat\", \"Mono8\");\n\n                HOperatorSet.GrabImageStart(acqHandle, -1);\n\n                // Acquire N lines (returns one line per external trigger)\n                for (int i = 0; i &lt; numLinesToGrab; i++)\n                {\n                    HObject oneLine = GrabOneLine(acqHandle, grabTimeoutMs);\n                    lineImages.Add(oneLine);\n                    if ((i + 1) % 100 == 0) Console.WriteLine($\"Grabbed lines: {i + 1}/{numLinesToGrab}\");\n                }\n\n                // Option to align widths for safety (should be same width basically)\n                if (enforceSameWidth) EqualizeWidthsInPlace(lineImages);\n\n                // Combine vertically (N rows x 1 column) to create 2D image\n                HObject fullImage = TileImagesVertically(lineImages);\n\n                Directory.CreateDirectory(Path.GetDirectoryName(savePath) ?? \".\");\n                HOperatorSet.WriteImage(fullImage, GetExtAsHalconType(savePath), 0, savePath);\n                Console.WriteLine($\"Saved: {savePath}\");\n\n                fullImage.Dispose();\n            }\n            catch (HalconException hex)\n            {\n                Console.Error.WriteLine($\"HALCON ERROR: #{hex.GetErrorCode()} {hex.GetErrorMessage()}\");\n            }\n            catch (Exception ex)\n            {\n                Console.Error.WriteLine($\"ERROR: {ex.Message}\");\n            }\n            finally\n            {\n                foreach (var img in lineImages) img?.Dispose();\n                if (acqHandle != null &amp;&amp; acqHandle.IsInitialized())\n                {\n                    try { HOperatorSet.CloseFramegrabber(acqHandle); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // Open GigE Vision frame grabber\n        static HTuple OpenGigEVision(string deviceUserID)\n        {\n            HOperatorSet.OpenFramegrabber(\n                \"GigEVision\",\n                0, 0, 0, 0, 0, 0,\n                \"progressive\",\n                -1,\n                \"default\",\n                -1,\n                \"false\",      // External trigger details set below\n                \"default\",\n                deviceUserID, // \"0\" or Camera UserID\n                0,\n                -1,\n                out HTuple acqHandle);\n\n            // Set bandwidth etc. here if needed (model dependent)\n            // HOperatorSet.SetFramegrabberParam(acqHandle, \"GevSCPSPacketSize\", 9000);\n\n            return acqHandle;\n        }\n\n        // Set line trigger (GenICam keys are model dependent. General example)\n        static void ConfigureLineTrigger(HTuple acqHandle, string triggerSource, string triggerActivation)\n        {\n            // Which event to trigger on: line unit\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerSelector\", \"LineStart\");\n\n            // Enable trigger\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerMode\", \"On\");\n\n            // External input line or encoder etc. (e.g., Line1)\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerSource\", triggerSource);\n\n            // Rising/Falling edge\n            HOperatorSet.SetFramegrabberParam(acqHandle, \"TriggerActivation\", triggerActivation);\n\n            // Set exposure or gain if needed\n            // HOperatorSet.SetFramegrabberParam(acqHandle, \"ExposureTime\", 20_000.0); // Example: 20,000 us\n            // For encoder synchronization, set model-specific features (e.g., LineTriggerSource=\"Encoder\" etc.)\n        }\n\n        // Acquire one line (blocks until external trigger arrives)\n        static HObject GrabOneLine(HTuple acqHandle, int timeoutMs)\n        {\n            // The third argument of GrabImageAsync is -1 for infinite wait. If you want to use timeout, set \"grab_timeout\" if supported by the model\n            HOperatorSet.GrabImageAsync(out HObject lineImg, acqHandle, -1);\n            return lineImg;\n        }\n\n        static HObject GrabOneLineOrBlack(HTuple acqHandle, int timeoutMs, int fallbackWidth = 4096, string pixelType = \"byte\")\n        {\n            try\n            {\n                // Normal 1-line acquisition (wait for external trigger)\n                HOperatorSet.GrabImageAsync(out HObject lineImg, acqHandle, -1);\n                return lineImg;\n            }\n            catch (HalconException ex)\n            {\n                Console.WriteLine($\"Grab failed: {ex.Message}  Fill with black line\");\n\n                // Generate a black image with a height of 1px (width can be specified as needed)\n                HOperatorSet.GenImageConst(out HObject blankLine, pixelType, fallbackWidth, 1);\n                return blankLine;\n            }\n        }\n\n\n        // Combine images vertically (N rows x 1 column)\n        static HObject TileImagesVertically(List&lt;HObject&gt; imageList)\n        {\n            if (imageList == null || imageList.Count == 0)\n                throw new ArgumentException(\"imageList is empty.\");\n\n            HOperatorSet.GenEmptyObj(out HObject all);\n            foreach (var img in imageList)\n            {\n                HOperatorSet.ConcatObj(all, img, out all);\n            }\n\n            HOperatorSet.TileImages(all, out HObject tiled, imageList.Count, 1);\n            all.Dispose();\n            return tiled;\n        }\n\n        // Align widths to the maximum (should be same width basically, but for safety)\n        static void EqualizeWidthsInPlace(List&lt;HObject&gt; imageList)\n        {\n            int maxWidth = 0;\n            var sizes = new List&lt;(int w, int h)&gt;(imageList.Count);\n\n            foreach (var img in imageList)\n            {\n                HOperatorSet.GetImageSize(img, out HTuple w, out HTuple h);\n                int wi = w.I, hi = h.I;         // For line, h is usually 1\n                sizes.Add((wi, hi));\n                if (wi &gt; maxWidth) maxWidth = wi;\n            }\n\n            for (int i = 0; i &lt; imageList.Count; i++)\n            {\n                var (w, h) = sizes[i];\n                if (w == maxWidth) continue;\n\n                double scale = (double)maxWidth / Math.Max(1, w);\n                int newH = Math.Max(1, (int)Math.Round(h * scale)); // h=1 is usual\n                HOperatorSet.ZoomImageSize(imageList[i], out HObject resized, maxWidth, newH, \"constant\");\n                imageList[i].Dispose();\n                imageList[i] = resized;\n            }\n        }\n\n        // Extension -&gt; HALCON write type\n        static string GetExtAsHalconType(string path)\n        {\n            var ext = Path.GetExtension(path)?.ToLowerInvariant();\n            return ext switch\n            {\n                \".png\" =&gt; \"png\",\n                \".jpg\" or \".jpeg\" =&gt; \"jpeg\",\n                \".bmp\" =&gt; \"bmp\",\n                \".tif\" or \".tiff\" =&gt; \"tiff\",\n                _ =&gt; \"png\"\n            };\n        }\n    }\n</code></pre>"},{"location":"golang-1/","title":"Go","text":"<p>Here is a basic code example for implementing the server side in Go. In this example, we will create a simple web server with the following functions.</p> <p>GET / : Returns \u201cHello, World!\u201d</p> <p>GET /users : Returns a list of users in JSON format</p> <p>POST /users : Adds a user (accepts JSON)</p> <p>```go</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\n// User model\ntype User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nvar users = []User{\n    {ID: 1, Name: \"Alice\"},\n    {ID: 2, Name: \"Bob\"},\n}\n\n// Handler: \"/\" \u2192 return Hello, World!\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, World!\")\n}\n\n// Handler: \"/users\" (GET) \u2192 return user list\nfunc getUsersHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(users)\n}\n\n// Handler: \"/users\" (POST) \u2192 add a new user\nfunc createUserHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodPost {\n        http.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    var newUser User\n    if err := json.NewDecoder(r.Body).Decode(&amp;newUser); err != nil {\n        http.Error(w, \"Bad Request\", http.StatusBadRequest)\n        return\n    }\n\n    newUser.ID = len(users) + 1\n    users = append(users, newUser)\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(newUser)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", helloHandler)\n    http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n        if r.Method == http.MethodGet {\n            getUsersHandler(w, r)\n        } else if r.Method == http.MethodPost {\n            createUserHandler(w, r)\n        } else {\n            http.Error(w, \"Method Not Allowed\", http.StatusMethodNotAllowed)\n        }\n    })\n\n    fmt.Println(\"\ud83d\ude80 Server is running at http://localhost:8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre>"}]}